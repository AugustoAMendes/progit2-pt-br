[[r_git_refs]]
=== Referências do Git

Você pode executar algo como `git log 1a410e` para ver todo o seu histórico, mas você ainda precisa lembrar que `1a410e` é o último _commit_ para poder caminhar nesse histórico para encontrar todos esses objetos.
Você precisa de um arquivo em que você possa armazenar o valor do SHA-1 com um simples nome para que você possa usar essa referência em vez do valor de um SHA-1 puro.

No Git, chamamos isso de ``referências'' (_references_) ou ``refs''; você pode encontrar os arquivos que contém os valores SHA-1 no diretório `.git/refs`.
No projeto atual, este diretório não contém nenhum arquivo, mas contém uma simples estrutura:

[source,console]
----
$ find .git/refs
.git/refs
.git/refs/heads
.git/refs/tags
$ find .git/refs -type f
----

Para criar uma nova referência que irá te ajudar a lembrar onde está seu último _commit_, você pode tecnicamente fazer algo tão simples quanto isto:

[source,console]
----
$ echo "1a410efbd13591db07496601ebc7a059dd55cfe9" > .git/refs/heads/master
----

Agora, você pode usar a referência _head_ que você acabou de criar em vez do valor SHA-1 nos seus comandos Git:

[source,console]
----
$ git log --pretty=oneline master
1a410efbd13591db07496601ebc7a059dd55cfe9 third commit
cac0cab538b970a37ea1e769cbbde608743bc96d second commit
fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit
----

Nós não encorajamos você a editar diretamente arquivos de referência.
O Git provê um comando mais seguro para fazer isso se você quiser atualizar uma referência, chamado `update-ref`:

[source,console]
----
$ git update-ref refs/heads/master 1a410efbd13591db07496601ebc7a059dd55cfe9
----

Isto é o que uma _branch_ é basicamente: uma simples referência para a cabeça de uma linha de trabalho.
Para criar uma _branch_ no segundo _commit_, você pode fazer isto:

[source,console]
----
$ git update-ref refs/heads/test cac0ca
----

Sua _branch_ irá conter apenas o trabalho a partir desse _commit_:

[source,console]
----
$ git log --pretty=oneline test
cac0cab538b970a37ea1e769cbbde608743bc96d second commit
fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit
----

Agora, seu banco de dados do Git conceitualmente aparenta ser algo assim:

.Git directory objects with branch head references included.
image::images/data-model-4.png[Objetos do diretório Git com todas as referências _head_ incluídas.]

Quando você executa comandos como `git branch (nome da branch)`, o Git basicamente executa esse comando `update-ref` para adicionar o SHA-1 do último _commit_ da _branch_ que você está em qualquer nova referência que você quer criar.

[[r_the_head]]
==== A HEAD

A questão agora é, quando você executa `git branch (nome da branch)`, como o Git sabe o SHA-1 do último _commit_?
A resposta é o arquivo HEAD.

O arquivo HEAD é uma referência simbólica para a _branch_ que você está no momento.
Queremos dizer por referência simbólica que, ao contrário de uma referência normal, em geral ela não contém um valor de um SHA-1, mas um ponteiro para outra referência.
Se você olhar para o arquivo, normalmente você verá algo como isto:

[source,console]
----
$ cat .git/HEAD
ref: refs/heads/master
----

Se você executar `git checkout test`, o Git atualizará o arquivo de forma que ele ficará assim:

[source,console]
----
$ cat .git/HEAD
ref: refs/heads/test
----

Quando você executa `git commit`, ele cria um objeto _commit_, especificando como pai desse objeto _commit_ o valor do SHA-1 que a referência contida em HEAD aponta.

Você pode alterar manualmente esse arquivo mas, novamente, um comando mais seguro existe para fazer isso: `symbolic-ref`.
Você pode ler esse arquivo de sua HEAD através deste comando:

[source,console]
----
$ git symbolic-ref HEAD
refs/heads/master
----

Você também pode definir o valor de HEAD:

[source,console]
----
$ git symbolic-ref HEAD refs/heads/test
$ cat .git/HEAD
ref: refs/heads/test
----

Você não pode definir o valor de uma referência simbólica fora do estilo _refs_:

[source,console]
----
$ git symbolic-ref HEAD test
fatal: Refusing to point HEAD outside of refs/
----

==== Tags

We just finished discussing Git's three main object types, but there is a fourth.
The tag object is very much like a commit object – it contains a tagger, a date, a message, and a pointer.
The main difference is that a tag object generally points to a commit rather than a tree.
It's like a branch reference, but it never moves – it always points to the same commit but gives it a friendlier name.

As discussed in <<ch02-git-basics#ch02-git-basics>>, there are two types of tags: annotated and lightweight.
You can make a lightweight tag by running something like this:

[source,console]
----
$ git update-ref refs/tags/v1.0 cac0cab538b970a37ea1e769cbbde608743bc96d
----

That is all a lightweight tag is – a reference that never moves.
An annotated tag is more complex, however.
If you create an annotated tag, Git creates a tag object and then writes a reference to point to it rather than directly to the commit.
You can see this by creating an annotated tag (`-a` specifies that it's an annotated tag):

[source,console]
----
$ git tag -a v1.1 1a410efbd13591db07496601ebc7a059dd55cfe9 -m 'test tag'
----

Here's the object SHA-1 value it created:

[source,console]
----
$ cat .git/refs/tags/v1.1
9585191f37f7b0fb9444f35a9bf50de191beadc2
----

Now, run the `cat-file` command on that SHA-1 value:

[source,console]
----
$ git cat-file -p 9585191f37f7b0fb9444f35a9bf50de191beadc2
object 1a410efbd13591db07496601ebc7a059dd55cfe9
type commit
tag v1.1
tagger Scott Chacon <schacon@gmail.com> Sat May 23 16:48:58 2009 -0700

test tag
----

Notice that the object entry points to the commit SHA-1 value that you tagged.
Also notice that it doesn't need to point to a commit; you can tag any Git object.
In the Git source code, for example, the maintainer has added their GPG public key as a blob object and then tagged it.
You can view the public key by running this in a clone of the Git repository:

[source,console]
----
$ git cat-file blob junio-gpg-pub
----

The Linux kernel repository also has a non-commit-pointing tag object – the first tag created points to the initial tree of the import of the source code.

==== Remotes

The third type of reference that you'll see is a remote reference.
If you add a remote and push to it, Git stores the value you last pushed to that remote for each branch in the `refs/remotes` directory.
For instance, you can add a remote called `origin` and push your `master` branch to it:

[source,console]
----
$ git remote add origin git@github.com:schacon/simplegit-progit.git
$ git push origin master
Counting objects: 11, done.
Compressing objects: 100% (5/5), done.
Writing objects: 100% (7/7), 716 bytes, done.
Total 7 (delta 2), reused 4 (delta 1)
To git@github.com:schacon/simplegit-progit.git
  a11bef0..ca82a6d  master -> master
----

Then, you can see what the `master` branch on the `origin` remote was the last time you communicated with the server, by checking the `refs/remotes/origin/master` file:

[source,console]
----
$ cat .git/refs/remotes/origin/master
ca82a6dff817ec66f44342007202690a93763949
----

Remote references differ from branches (`refs/heads` references) mainly in that they're considered read-only.
You can `git checkout` to one, but Git won't point HEAD at one, so you'll never update it with a `commit` command.
Git manages them as bookmarks to the last known state of where those branches were on those servers.
