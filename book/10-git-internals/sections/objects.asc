[[r_objects]]
=== Objetos do Git

O Git é um sistema de arquivos de conteúdo endereçável.
Ótimo.
O que isso significa?
Isso significa que o coração do Git é um simples armazenamento chave-valor.
Você pode inserir qualquer tipo de conteúdo nele, e ele lhe dará de volta uma chave que você pode usar para recuperar o conteúdo de volta em qualquer momento.
Para demonstrar isso, você pode usar o comando de encanamento `hash-object`, que recebe alguns dados, armazena eles em seu diretório `.git`, e lhe devolve de volta a chave com o qual os dados são armazenados.
Primeiramente, inicialize um novo repositório Git e verifique que não há nada no diretório `objects`:

[source,console]
----
$ git init test
Initialized empty Git repository in /tmp/test/.git/
$ cd test
$ find .git/objects
.git/objects
.git/objects/info
.git/objects/pack
$ find .git/objects -type f
----

O Git inicializou o diretório `objects` diretamente e criou os subdiretórios `pack` e `info` dentro dele, mas não há nenhum arquivo regular.
Agora, guarde algum texto no seu banco de dados do Git:

[source,console]
----
$ echo 'test content' | git hash-object -w --stdin
d670460b4b4aece5915caf5c68d12f560a9fe3e4
----

A _flag_`-w` diz ao `hash-object` para armazenar o objeto. Caso contrário, o comando simplesmente lhe diria a chave.
`--stdin` diz ao comando para ler o conteúdo do stdin; se você não especificar isto, `hash-object` espera um caminho para um arquivo no fim.
A saída do comando é um `checksum hash` de 40 caracteres.
Esse é o _hash_ SHA-1 - um `checksum` do conteúdo que você está armazendo mais um cabeçalho, que você aprenderá em breve.
Agora você pode ver como o Git armazenou seus dados:

[source,console]
----
$ find .git/objects -type f
.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4
----

Você pode ver um arquivo no diretório `objects`.
É assim que o Git armazena o conteúdo inicialmente - como um simples arquivo por porção de conteúdo, nomeado com o _checksum_ SHA-1 do conteúdo e seu cabeçalho.
O subdiretório é nomeado com os dois primeiros caracteres do SHA-1, e o nome do arquivo são os 38 caracteres restantes.

Você pode recuperar o conteúdo para fora do Git com o comando `cat-file`.
Esse comando é um canivete suíço para a inspeção de objetos do Git.
Passando `-p` para ele faz com que o `cat-file` descubra o tipo do conteúdo e o mostre gentilmente para você:


[source,console]
----
$ git cat-file -p d670460b4b4aece5915caf5c68d12f560a9fe3e4
test content
----

Agora, você pode adicionar conteúdo para o Git e recuperá-lo de volta.
Você também pode fazer isso para conteúdos em arquivos.
Por exemplo, você pode fazer um controle de versão simples em um arquivo.
Primeiro, crie um arquivo e salve seus conteúdos em seu banco de dados:

[source,console]
----
$ echo 'version 1' > test.txt
$ git hash-object -w test.txt
83baae61804e65cc73a7201a7252750c76066a30
----

Depois, escreva alguns conteúdos novos nesse arquivo, e salve-o novamente:

[source,console]
----
$ echo 'version 2' > test.txt
$ git hash-object -w test.txt
1f7a7a472abf3dd9643fd615f6da379c4acb3e3a
----

Seu banco de dados contém as duas novas versões do arquivo, além do primeiro conteúdo que você gravou:

[source,console]
----
$ find .git/objects -type f
.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a
.git/objects/83/baae61804e65cc73a7201a7252750c76066a30
.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4
----

Agora você pode reverter o arquivo de volta à primeira versão:

[source,console]
----
$ git cat-file -p 83baae61804e65cc73a7201a7252750c76066a30 > test.txt
$ cat test.txt
version 1
----

ou à segunda versão:

[source,console]
----
$ git cat-file -p 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a > test.txt
$ cat test.txt
version 2
----

Lembrando que decorar a chave SHA-1 para cada versão de seu arquivo não é prático; além disso, você não está armazenando o nome do arquivo em seu sitema - apenas o conteúdo.
Este tipo de objeto é chamado de _blob_.
Você pode pedir para o Git lhe dizer o tipo de objeto de qualquer objeto, dado sua chave SHA-1, com `cat-file -t`:

[source,console]
----
$ git cat-file -t 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a
blob
----

[[r_tree_objects]]
==== Objetos Tree

O próximo tipo que iremos ver é a _tree_ (árvore), que resolve o problema de armazenar o nome de arquivo e também permite armazenar de forma conjunta um grupo de arquivos.
O Git armazena o conteúdo em uma maneira similar a um sistema de arquivos UNIX, porém um pouco simplificado.
Todo o conteúdo é armazenado como objetos _tree_ e _blob_, com as _trees_ correspondendo a entradas de um diretório UNIX e _blobs_ correspondendo mais ou menos a _inodes_ ou conteúdos de arquivos.
Um único objeto _tree_ contém uma ou mais entradas, cada uma contendo uma referência SHA-1 para um _blob_ ou _subtree_ com seu modo, tipo e nome de arquivo associados.
Por exemplo, a _tree_ mais recente em um projeto deverá se parecer com algo assim:

[source,console]
----
$ git cat-file -p master^{tree}
100644 blob a906cb2a4a904a152e80877d4088654daad0c859      README
100644 blob 8f94139338f9404f26296befa88755fc2598c289      Rakefile
040000 tree 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0      lib
----

A sintaxe `master^{tree}` especifica o objeto _tree_ que é apontado pelo último _commit_ em sua _branch_ `master` .
Note que o subdiretório `lib` não é um _blob_, mas uma referência para outra _tree_:

[source,console]
----
$ git cat-file -p 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0
100644 blob 47c6340d6459e05787f644c2447d2595f5d3a54b      simplegit.rb
----

Conceitualmente, os dados que são armazenados pelo Git é algo assim:

.Versão simples do modelo de dados do Git.
image::images/data-model-1.png[Versão simples do modelo de dados do Git.]

Você pode criar facilmente a sua própria _tree_.
O Git normalmente cria uma _tree_ a partir do estado da sua área de _stage_ ou _index_ e escrevendo uma série de objetos _tree_ a partir dela.
Então, para criar um objeto _tree_, você primeiro precisa popular um _index_ adicionando alguns arquivos.
Para criar um _index_ com apenas uma entrada - a primeira versão do do seu arquivo `test.txt` - você pode usar o comando `update-index`.
Você usa esse comando para adicionar artificialmente a versão anterior do arquivo `test.txt` à nova área de _stage_.
Você precisa passar a ele a opção `--add` porque o arquivo ainda não existe em sua área de _stage_ (você nem precisa ter uma área de _stage_ ainda) e a opção `--cacheinfo` porque o arquivo que você está adicionando não está em seu diretório mas está no seu banco de dados.
Depois você especifica o modo, o SHA-1 e o nome do arquivo:

[source,console]
----
$ git update-index --add --cacheinfo 100644 \
  83baae61804e65cc73a7201a7252750c76066a30 test.txt
----

Neste caso, você está especificando um modo `100644`, o que significa se trata de um arquivo normal.
Outras opções são `100755`, o que significa que é um arquivo executável; e `120000`, que especifica um link simbólico.
O modo vem dos modos UNIX normais, mas é muito menos flexível - esses três modos são os únicos que são válidos para arquivos (_blobs_) no Git (ainda que outros modos possam ser usados para diretórios e submódulos).

Agora, você pode usar o comando `write-tree` para escrever a área de _stage_ para um objeto _tree_.
A opção `-w` não é necessária - chamar `write-tree` automaticamente cria um objeto `tree` a partir do estado do _index_ caso a _tree_ ainda não exista:

[source,console]
----
$ git write-tree
d8329fc1cc938780ffdd9f94e0d364e0ea74f579
$ git cat-file -p d8329fc1cc938780ffdd9f94e0d364e0ea74f579
100644 blob 83baae61804e65cc73a7201a7252750c76066a30      test.txt
----

Você também pode verificar que se este é um arquivo _tree_:

[source,console]
----
$ git cat-file -t d8329fc1cc938780ffdd9f94e0d364e0ea74f579
tree
----

Você pode criar um novo arquivo _tree_ com a segunda versão de `test.txt`, além de um novo arquivo:

[source,console]
----
$ echo 'new file' > new.txt
$ git update-index --cacheinfo 100644 \
  1f7a7a472abf3dd9643fd615f6da379c4acb3e3a test.txt
$ git update-index test.txt
$ git update-index --add new.txt
----

Sua área de _stage_ agora tem a nova versão de `test.txt`, bem como o novo arquivo `new.txt`.
Escreva essa _tree_ (grave o estado da área de _stage_ ou _index_ para um objeto) e veja como ela se parece:

[source,console]
----
$ git write-tree
0155eb4229851634a0f03eb265b69f5a2d56f341
$ git cat-file -p 0155eb4229851634a0f03eb265b69f5a2d56f341
100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt
100644 blob 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a      test.txt
----

Note que essa _tree_ tem ambas as entradas de arquivo além de que o SHA-1 de `test.txt` é a o SHA-1 da ``versão 2'' que falamos anteriormente (`1f7a7a`).
Apenas por diversão, adicione a primeira _tree_ como um subdiretório neste aqui.
Você pode ler as _trees_ para a área de _stage_ chamando `read-tree`.
Neste caso, você pode ler uma _tree_ existente em sua área de _stage_ como uma _subtree_ usando a opção `--prefix` em `read-tree`:

[source,console]
----
$ git read-tree --prefix=bak d8329fc1cc938780ffdd9f94e0d364e0ea74f579
$ git write-tree
3c4e9cd789d88d8d89c1073707c3585e41b0e614
$ git cat-file -p 3c4e9cd789d88d8d89c1073707c3585e41b0e614
040000 tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579      bak
100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt
100644 blob 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a      test.txt
----

Se você criasse um diretório de trabalho a partir da nova _tree_ que você criou, você teria os dois arquivos no nível mais alto do diretório de trabalho e um subdiretório chamado `bak` que conteria a primeira versão do arquivo `test.txt`.
Você pode pensar nos dados que o Git armazena para essas estruturas como sendo algo assim:

.A estrutura atual do conteúdo dos seus dados no Git.
image::images/data-model-2.png[A estrutura atual do conteúdo dos seus dados no Git.]

[[r_git_commit_objects]]
==== Commit Objects

You have three trees that specify the different snapshots of your project that you want to track, but the earlier problem remains: you must remember all three SHA-1 values in order to recall the snapshots.
You also don't have any information about who saved the snapshots, when they were saved, or why they were saved.
This is the basic information that the commit object stores for you.

To create a commit object, you call `commit-tree` and specify a single tree SHA-1 and which commit objects, if any, directly preceded it.
Start with the first tree you wrote:

[source,console]
----
$ echo 'first commit' | git commit-tree d8329f
fdf4fc3344e67ab068f836878b6c4951e3b15f3d
----

You will get a different hash value because of different creation time and author data.
Replace commit and tag hashes with your own checksums further in this chapter.
Now you can look at your new commit object with `cat-file`:

[source,console]
----
$ git cat-file -p fdf4fc3
tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579
author Scott Chacon <schacon@gmail.com> 1243040974 -0700
committer Scott Chacon <schacon@gmail.com> 1243040974 -0700

first commit
----

The format for a commit object is simple: it specifies the top-level tree for the snapshot of the project at that point; the author/committer information (which uses your `user.name` and `user.email` configuration settings and a timestamp); a blank line, and then the commit message.

Next, you'll write the other two commit objects, each referencing the commit that came directly before it:

[source,console]
----
$ echo 'second commit' | git commit-tree 0155eb -p fdf4fc3
cac0cab538b970a37ea1e769cbbde608743bc96d
$ echo 'third commit'  | git commit-tree 3c4e9c -p cac0cab
1a410efbd13591db07496601ebc7a059dd55cfe9
----

Each of the three commit objects points to one of the three snapshot trees you created.
Oddly enough, you have a real Git history now that you can view with the `git log` command, if you run it on the last commit SHA-1:

[source,console]
----
$ git log --stat 1a410e
commit 1a410efbd13591db07496601ebc7a059dd55cfe9
Author: Scott Chacon <schacon@gmail.com>
Date:   Fri May 22 18:15:24 2009 -0700

	third commit

 bak/test.txt | 1 +
 1 file changed, 1 insertion(+)

commit cac0cab538b970a37ea1e769cbbde608743bc96d
Author: Scott Chacon <schacon@gmail.com>
Date:   Fri May 22 18:14:29 2009 -0700

	second commit

 new.txt  | 1 +
 test.txt | 2 +-
 2 files changed, 2 insertions(+), 1 deletion(-)

commit fdf4fc3344e67ab068f836878b6c4951e3b15f3d
Author: Scott Chacon <schacon@gmail.com>
Date:   Fri May 22 18:09:34 2009 -0700

    first commit

 test.txt | 1 +
 1 file changed, 1 insertion(+)
----

Amazing.
You've just done the low-level operations to build up a Git history without using any of the front end commands.
This is essentially what Git does when you run the `git add` and `git commit` commands – it stores blobs for the files that have changed, updates the index, writes out trees, and writes commit objects that reference the top-level trees and the commits that came immediately before them.
These three main Git objects – the blob, the tree, and the commit – are initially stored as separate files in your `.git/objects` directory.
Here are all the objects in the example directory now, commented with what they store:

[source,console]
----
$ find .git/objects -type f
.git/objects/01/55eb4229851634a0f03eb265b69f5a2d56f341 # tree 2
.git/objects/1a/410efbd13591db07496601ebc7a059dd55cfe9 # commit 3
.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a # test.txt v2
.git/objects/3c/4e9cd789d88d8d89c1073707c3585e41b0e614 # tree 3
.git/objects/83/baae61804e65cc73a7201a7252750c76066a30 # test.txt v1
.git/objects/ca/c0cab538b970a37ea1e769cbbde608743bc96d # commit 2
.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4 # 'test content'
.git/objects/d8/329fc1cc938780ffdd9f94e0d364e0ea74f579 # tree 1
.git/objects/fa/49b077972391ad58037050f2a75f74e3671e92 # new.txt
.git/objects/fd/f4fc3344e67ab068f836878b6c4951e3b15f3d # commit 1
----

If you follow all the internal pointers, you get an object graph something like this:

.All the objects in your Git directory.
image::images/data-model-3.png[All the objects in your Git directory.]

==== Object Storage

We mentioned earlier that a header is stored with the content.
Let's take a minute to look at how Git stores its objects.
You'll see how to store a blob object – in this case, the string ``what is up, doc?'' – interactively in the Ruby scripting language.

You can start up interactive Ruby mode with the `irb` command:

[source,console]
----
$ irb
>> content = "what is up, doc?"
=> "what is up, doc?"
----

Git constructs a header that starts with the type of the object, in this case a blob.
Then, it adds a space followed by the size of the content and finally a null byte:

[source,console]
----
>> header = "blob #{content.length}\0"
=> "blob 16\u0000"
----

Git concatenates the header and the original content and then calculates the SHA-1 checksum of that new content.
You can calculate the SHA-1 value of a string in Ruby by including the SHA1 digest library with the `require` command and then calling `Digest::SHA1.hexdigest()` with the string:

[source,console]
----
>> store = header + content
=> "blob 16\u0000what is up, doc?"
>> require 'digest/sha1'
=> true
>> sha1 = Digest::SHA1.hexdigest(store)
=> "bd9dbf5aae1a3862dd1526723246b20206e5fc37"
----

Git compresses the new content with zlib, which you can do in Ruby with the zlib library.
First, you need to require the library and then run `Zlib::Deflate.deflate()` on the content:

[source,console]
----
>> require 'zlib'
=> true
>> zlib_content = Zlib::Deflate.deflate(store)
=> "x\x9CK\xCA\xC9OR04c(\xCFH,Q\xC8,V(-\xD0QH\xC9O\xB6\a\x00_\x1C\a\x9D"
----

Finally, you'll write your zlib-deflated content to an object on disk.
You'll determine the path of the object you want to write out (the first two characters of the SHA-1 value being the subdirectory name, and the last 38 characters being the filename within that directory).
In Ruby, you can use the `FileUtils.mkdir_p()` function to create the subdirectory if it doesn't exist.
Then, open the file with `File.open()` and write out the previously zlib-compressed content to the file with a `write()` call on the resulting file handle:

[source,console]
----
>> path = '.git/objects/' + sha1[0,2] + '/' + sha1[2,38]
=> ".git/objects/bd/9dbf5aae1a3862dd1526723246b20206e5fc37"
>> require 'fileutils'
=> true
>> FileUtils.mkdir_p(File.dirname(path))
=> ".git/objects/bd"
>> File.open(path, 'w') { |f| f.write zlib_content }
=> 32
----

That's it – you've created a valid Git blob object.
All Git objects are stored the same way, just with different types – instead of the string blob, the header will begin with commit or tree.
Also, although the blob content can be nearly anything, the commit and tree content are very specifically formatted.
