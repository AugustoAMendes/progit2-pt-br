=== O básico de Ramificação (Branch) e Mesclagem (Merge)

Vamos examinar um exemplo simples de ramificação (branch) e mesclagem (merge) com um fluxo de trabalho que você pode usar no mundo real.
Você seguirá estas etapas:

. Trabalhe em um site.
. Crie um branch para uma nova história na qual você está trabalhando.
. Faça algum trabalho nesse branch.

Nessa etapa, você receberá uma ligação informando que outro problema é crítico e que você precisa corrigí-lo.
Você fará o seguinte:

. Mude para o seu branch de produção.
. Crie um novo branch para adicionar a correção.
. Depois de testado, mescle o branch de correção e envie para produção.
. Volte para sua história original e continue trabalhando.

[[r_basic_branching]]
==== O básico sobre Branch

(((branches, basic workflow)))
Primeiro, digamos que você esteja trabalhando em seu projeto e já tenha alguns commits.

.Histórico de um commit simples
image::images/basic-branching-1.png[A simple commit history.]

Você decidiu que trabalhará na publicação #53 em qualquer sistema de publicações que sua empresa use.
Para criar um branch e alternar para ele ao mesmo tempo, você pode executar o comando `git checkout` com a opção` -b`:

[source,console]
----
$ git checkout -b iss53
Switched to a new branch "iss53"
----

Esta é a abreviação de:

[source,console]
----
$ git branch iss53
$ git checkout iss53
----

.Criando um novo branch
image::images/basic-branching-2.png[Creating a new branch pointer.]

Você trabalha no seu site e faz alguns commits.
Fazer isso move o branch `iss53` para frente, porque você o verificou (ou seja, seu` HEAD` está apontando para ele agora):

[source,console]
----
$ vim index.html
$ git commit -a -m 'added a new footer [issue 53]'
----

.Após o commit, o branch `iss53` se moveu para frente
image::images/basic-branching-3.png[The `iss53` branch has moved forward with your work.]

Agora você recebe uma ligação informando que há um problema com o site e é necessário corrigi-lo imediatamente.
Com o Git, você não precisa fazer sua correção junto com as mudanças do branch `iss53` que você fez, e você não precisa se esforçar muito para reverter essas mudanças antes de poder trabalhar na sua correção para o que está em produção.
Tudo que você precisa fazer é voltar para o branch `master`.

No entanto, antes de fazer isso, observe que se seu diretório de trabalho ou `staged area` tiver alterações não confirmadas que entrem em conflito com o branch que você está fazendo check-out, o Git não permitirá que você alterne os branches.
É melhor que os trabalhos estejam concluídos ao alternar entre os branches.
Existem maneiras de contornar isso (ou seja, esconder e corrigir o commit) que citaremos mais tarde,<<ch07-git-tools#r_git_stashing>>.
Por enquanto, vamos supor que você fez o commit de todas as suas alterações, então você pode retornar para o branch `master`:

[source,console]
----
$ git checkout master
Switched to branch 'master'
----

Neste ponto, o diretório de trabalho do seu projeto está exatamente do jeito que estava antes de você começar a trabalhar no problema #53, e você pode se concentrar na sua correção.
Este é um ponto importante a ser lembrado: quando você muda de branch, o Git redefine seu diretório de trabalho para ficar como da última vez que você fez commit naquele branch.
Ele adiciona, remove e modifica arquivos automaticamente para garantir que sua cópia de trabalho seja a aparência do branch em seu último commit.

Em seguida, você precisa fazer a correção.
Vamos criar um branch `hotfix` no qual você irá trabalhar até que seja concluído:

[source,console]
----
$ git checkout -b hotfix
Switched to a new branch 'hotfix'
$ vim index.html
$ git commit -a -m 'fixed the broken email address'
[hotfix 1fb7853] fixed the broken email address
 1 file changed, 2 insertions(+)
----

.Branch Hotfix  com base no `master`
image::images/basic-branching-4.png[Hotfix branch based on `master`.]

Você pode executar seus testes e certificar-se de que as correções feitas é o que você deseja. Então faça o merge com seu branch `master` para implantar na produção.
Vocês faz isso usando o comando `git merge`:(((git commands, merge)))

[source,console]
----
$ git checkout master
$ git merge hotfix
Updating f42c576..3a0874c
Fast-forward
 index.html | 2 ++
 1 file changed, 2 insertions(+)
----

Você verá a frase ``fast-forward'' após o merge.
Como o commit `C4` apontado pelo branch` hotfix` em que você fez o merge estava diretamente antes do commit `C2` em que você está, o Git simplesmente move o ponteiro para frente.
Para expressar isso de outra maneira, quando você tenta mesclar um commit com um commit que pode ser alcançado seguindo o histórico do primeiro commit, o Git simplifica as coisas movendo o ponteiro para frente porque não há trabalho divergente para mesclar - isso é chamado de ` `fast-forward. ''

Sua mudança está agora no snapshot do commit apontado pelo branch `master`, e você pode aplicar a correção.

.`master` é simplesmente movido para o `hotfix`
image::images/basic-branching-5.png[`master` is fast-forwarded to `hotfix`.]

Depois que sua correção super importante for implantada, você estará pronto para voltar ao trabalho que estava fazendo antes de ser interrompido.
No entanto, primeiro você excluirá o branch `hotfix`, porque você não precisa mais dele - o branch` master` aponta para o mesmo lugar.
Você pode excluí-lo com a opção `-d` para` git branch`:

[source,console]
----
$ git branch -d hotfix
Deleted branch hotfix (3a0874c).
----

Agora você pode voltar para o branch de trabalho em andamento na publicação #53 e continuar trabalhando nele.

[source,console]
----
$ git checkout iss53
Switched to branch "iss53"
$ vim index.html
$ git commit -a -m 'finished the new footer [issue 53]'
[iss53 ad82d7a] finished the new footer [issue 53]
1 file changed, 1 insertion(+)
----

.O trabalho continua em `iss53`
image::images/basic-branching-6.png[Work continues on `iss53`.]

É importante notar aqui que o trabalho que você fez em seu branch `hotfix` não está contido nos arquivos em seu branch` iss53`.
Se você precisar puxá-lo, você pode mesclar seu branch `master` com seu branch` iss53` executando `git merge master`, ou você pode esperar para integrar essas mudanças quando decidir mesclar o branch` iss53` de volta para `master`.

[[r_basic_merging]]
==== Básico sobre mesclagem (Merging)

(((branches, merging)))(((merging)))
Suponha que você decidiu que seu trabalho #53 está completo e pronto para ser mesclado em seu branch `master`.
Para fazer isso, você mesclará seu branch `iss53` com o ` master`, da mesma forma que fez com o branch `hotfix` anteriormente.
Tudo que você precisa fazer é mudar para o branch no qual deseja mesclar e, em seguida, executar o comando `git merge`:

[source,console]
----
$ git checkout master
Switched to branch 'master'
$ git merge iss53
Merge made by the 'recursive' strategy.
index.html |    1 +
1 file changed, 1 insertion(+)
----

Isso parece um pouco diferente do merge feito anteriormente no `hotfix`.
Nesse caso, seu histórico de desenvolvimento divergiu em algum ponto mais antigo.
Como o commit no branch em que você está não é um ancestral direto do branch no qual você está mesclando, o Git precisa fazer algum trabalho.
Nesse caso, o Git faz uma fusão simples de três vias, usando os dois snapshots apontados pelas pontas dos branhes e o ancestral comum dos dois.

.Três snapshots usados em um merge típico
image::images/basic-merging-1.png[Three snapshots used in a typical merge.]

Em vez de apenas mover o ponteiro do branch para frente, o Git cria um novo snapshot que resulta dessa fusão de três vias e cria automaticamente um novo commit que aponta para ele.
Isso é conhecido como consolidação de mesclagem e é especial porque tem mais de um pai.

.Um merge commit
image::images/basic-merging-2.png[A merge commit.]

É importante ressaltar que o Git determina o melhor ancestral comum a ser usado para sua base de mesclagem; isso é diferente de ferramentas mais antigas, como CVS ou Subversion (antes da versão 1.5), onde o desenvolvedor que fazia a fusão tinha que descobrir a melhor base de fusão por si mesmo.
Isso torna a fusão muito mais fácil no Git do que nesses outros sistemas.

Agora que seu trabalho está integrado, você não precisa mais do branch `iss53`.
Você pode fechar a atividade em seu sistema de publicações e remover o branch:

[source,console]
----
$ git branch -d iss53
----

[[r_basic_merge_conflicts]]
==== Conflitos ao fazer o Merge

(((merging, conflicts)))
Algumas vezes, esse processo não ocorre sem problemas.
Se você alterou a mesma parte do mesmo arquivo de maneira diferente nos dois branches que está mesclando, o Git não será capaz de mesclá-los automaticamente.
Se a sua correção para o problema #53 modificou a mesma parte de um arquivo que o `hotfix`, você vai ter um conflito de merge semelhante a este:

[source,console]
----
$ git merge iss53
Auto-merging index.html
CONFLICT (content): Merge conflict in index.html
Automatic merge failed; fix conflicts and then commit the result.
----

O Git não cria automaticamente um novo commit de merge.
Ele pausa o processo enquanto você resolve o conflito.
Se você quiser ver quais arquivos foram removidos do merge a qualquer momento após um conflito, você pode executar `git status`:

[source,console]
----
$ git status
On branch master
You have unmerged paths.
  (fix conflicts and run "git commit")

Unmerged paths:
  (use "git add <file>..." to mark resolution)

    both modified:      index.html

no changes added to commit (use "git add" and/or "git commit -a")
----

Qualquer coisa que tenha conflitos de merge e não tenha sido resolvida é listada como `unmerged`.
O Git adiciona marcadores de resolução de conflito padrão aos arquivos, para que você possa abri-los manualmente e resolver esses conflitos.
Seu arquivo conterá uma seção semelhante a esta:

[source,html]
----
<<<<<<< HEAD:index.html
<div id="footer">contact : email.support@github.com</div>
=======
<div id="footer">
 please contact us at support@github.com
</div>
>>>>>>> iss53:index.html
----

Isto significa que a versão em `HEAD` (seu branch` master`, porque foi isso que você verificou quando executou o comando merge) é a parte superior desse bloco (tudo acima de `=======` ), enquanto a versão em seu branch `iss53` se parece com tudo na parte inferior.
Para resolver o conflito, você deve escolher um lado ou outro ou mesclar os conteúdos você mesmo.
Por exemplo, você pode resolver esse conflito substituindo todo o bloco por este:

[source,html]
----
<div id="footer">
please contact us at email.support@github.com
</div>
----

Esaa resolução possui um pouco de cada seção, e as linhas `<<<<<<<`, `=======` e `>>>>>>>` foram completamente removidas.
Depois de resolver cada uma dessas seções em cada arquivo em conflito, execute `git add` para cada arquivo a fim de  marcá-lo como resolvido.
Esse comando informa para o Git que o conflito foi resolvido.

Se você quiser usar uma ferramenta gráfica para resolver esses problemas, pode executar `git mergetool`, que aciona uma ferramenta de mesclagem visual apropriada e orienta você através dos conflitos:(((git commands, mergetool)))

[source,console]
----
$ git mergetool

This message is displayed because 'merge.tool' is not configured.
See 'git mergetool --tool-help' or 'git help config' for more details.
'git mergetool' will now attempt to use one of the following tools:
opendiff kdiff3 tkdiff xxdiff meld tortoisemerge gvimdiff diffuse diffmerge ecmerge p4merge araxis bc3 codecompare vimdiff emerge
Merging:
index.html

Normal merge conflict for 'index.html':
  {local}: modified file
  {remote}: modified file
Hit return to start merge resolution tool (opendiff):
----

If you want to use a merge tool other than the default (Git chose `opendiff` in this case because the command was run on a Mac), you can see all the supported tools listed at the top after ``one of the following tools.''
Just type the name of the tool you'd rather use.
Se você quiser usar uma ferramenta de mesclagem diferente da padrão (O Git selecionou o `opendiff` neste caso porque o comando foi executado em um Mac), você pode ver todas as ferramentas suportadas listadas no topo após` `uma das seguintes ferramentas . ''
Basta digitar o nome da ferramenta que você prefere usar.

[NOTE]
====
Se você precisar de ferramentas mais avançadas para resolver conflitos de merge mais complicados, falamos mais sobre merge em<<ch07-git-tools#r_advanced_merging>>.
====

Depois de sair da ferramenta de merge, o Git pergunta se a mesclagem foi bem-sucedida.
Se você disser ao script que sim, ele organizará o arquivo para marcá-lo como resolvido para você.
Você pode executar `git status` novamente para verificar se todos os conflitos foram resolvidos:

[source,console]
----
$ git status
On branch master
All conflicts fixed but you are still merging.
  (use "git commit" to conclude merge)

Changes to be committed:

    modified:   index.html
----

Se você estiver satisfeito e verificar que tudo o que havia conflitos foi testado, você pode digitar `git commit` para finalizar o commit.
A mensagem de confirmação por padrão é semelhante a esta:

[source,console]
----
Merge branch 'iss53'

Conflicts:
    index.html
#
# It looks like you may be committing a merge.
# If this is not correct, please remove the file
#	.git/MERGE_HEAD
# and try again.


# Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
# On branch master
# All conflicts fixed but you are still merging.
#
# Changes to be committed:
#	modified:   index.html
#
----

Se você acha que seria útil para outras pessoas olhar para este merge no futuro, você pode modificar esta mensagem de confirmação com detalhes sobre como você resolveu o conflito e explicar por que você fez as mudanças que você fez se elas não forem óbvias.
